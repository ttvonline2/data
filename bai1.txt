function main
    T ← readInt
    loop caseId from 1 to T
        R C N r c ← readInts
        pawns ← empty list
        loop i from 1 to N
            x y ← readInts
            append (x-1, y-1) to pawns
        grid ← array of R strings
        loop i from 0 to R-1
            grid[i] ← readString
        score net ← solveCase(R, C, N, (r-1, c-1), pawns, grid)
        print score, net

function solveCase(R, C, N, dest, pawns, grid)
    distDest ← bfsFrom(dest, grid, R, C)
    oldDist ← array of N
    loop i from 0 to N-1
        oldDist[i] ← distDest[pawns[i]]
    score ← sum of oldDist
    walls ← listWalls(grid, R, C)
    destPart ← prepDestPart(walls, distDest, grid, R, C)
    pawnDist ← array of N
    loop i from 0 to N-1
        pawnDist[i] ← bfsFrom(pawns[i], grid, R, C)
    net ← 0
    loop wIndex from 0 to size(walls)-1
        newScore ← 0
        loop i from 0 to N-1
            entry ← bestEntry(walls[wIndex], pawnDist[i], grid, R, C)
            cand ← entry + destPart[wIndex]
            best ← min(oldDist[i], cand)
            newScore ← newScore + best
        net ← net + score - newScore
    return score, net

function bfsFrom(start, grid, R, C)
    dist ← matrix R × C filled with INF
    queue ← empty deque
    dist[start] ← 0
    pushBack queue start
    while queue not empty
        u ← popFront queue
        for each dir in fourDirections
            v ← u + dir
            if inside(v, R, C) and grid[v] ≠ 'W' and dist[v] = INF
                dist[v] ← dist[u] + 1
                pushBack queue v
    return dist

function listWalls(grid, R, C)
    walls ← empty list
    loop i from 0 to R-1
        loop j from 0 to C-1
            if grid[i][j] = 'W'
                append (i, j) to walls
    return walls

function prepDestPart(walls, distDest, grid, R, C)
    destPart ← array size(walls) filled with INF
    loop idx from 0 to size(walls)-1
        w ← walls[idx]
        best ← INF
        for each dir in fourDirections
            n ← w + dir
            if inside(n, R, C) and grid[n] ≠ 'W'
                best ← min(best, distDest[n] + 1)
        destPart[idx] ← best
    return destPart

function bestEntry(wall, distMap, grid, R, C)
    best ← INF
    for each dir in fourDirections
        n ← wall + dir
        if inside(n, R, C) and grid[n] ≠ 'W'
            best ← min(best, distMap[n] + 1)
    return best

function inside(cell, R, C)
    return 0 ≤ cell.row < R and 0 ≤ cell.col < C
