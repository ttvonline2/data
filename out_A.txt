Ý tưởng tổng quan

Khi nào một đoạn được cộng điểm ?
– Độ dài phải ≥ 3 .
– Giá trị lớn nhất ở giữa không được vượt quá giá trị nhỏ hơn trong hai đầu đoạn .
→ Hình dung đầu “ thấp ” ( giá trị nhỏ hơn ) như một cái nắp , mọi phần tử nằm giữa hai đầu phải chui lọt dưới cái nắp đó .

Cố định đầu “ thấp ”
Gọi chỉ số đầu thấp là i ( giả sử
<<< 𝐵 >>>
<<< 𝑖 >>>
≤
<<< 𝐵 >>>
<<< 𝑗 >>>
B
i
​
≤ B
j
​
) .
Điều kiện trở thành :
– Chọn một vị trí j > i + 1 .
–
<<< 𝐵 >>>
<<< 𝑗 >>>
≥
<<< 𝐵 >>>
<<< 𝑖 >>>
B
j
​
≥ B
i
​
( đầu còn lại không thấp hơn nắp ) .
– Tất cả phần tử giữa i và j đều ≤
<<< 𝐵 >>>
<<< 𝑖 >>>
B
i
​
.

Khoanh đoạn an toàn quanh mỗi vị trí
Với mỗi vị trí i , tìm biên trái L [ i ] và biên phải R [ i ] gần nhất có giá trị >
<<< 𝐵 >>>
<<< 𝑖 >>>
B
i
​
.
Trong đoạn liên tiếp
[

<<< 𝐿 >>>
[
<<< 𝑖 >>>
]
+
1
,

<<< 𝑅 >>>
[
<<< 𝑖 >>>
]
−
1
]
[ L [ i ] + 1 , R [ i ] − 1 ] mọi phần tử ≤
<<< 𝐵 >>>
<<< 𝑖 >>>
B
i
​
.
→ Nếu j nằm trong
[
<<< 𝑖 >>>
+
2
,

<<< 𝑅 >>>
[
<<< 𝑖 >>>
]
−
1
]
[ i + 2 , R [ i ] − 1 ] thì điều kiện “ lọt nắp ” tự đảm bảo .

L [ i ] , R [ i ] tính nhanh bằng <<< s t a c k >>> đơn điệu ( duyệt một lần từ trái qua phải cho R , từ phải sang trái cho L ) .

Đếm nhanh các j phù hợp
Duyệt các vị trí theo giá trị giảm dần .
– Những chỉ số đã duyệt luôn có
<<< 𝐵 >>>
<<< 𝑘 >>>
≥
<<< 𝐵 >>>
<<< 𝑖 >>>
B
k
​
≥ B
i
​
.
– Lưu các chỉ số đã duyệt vào một cấu trúc <<< F e n w i c k >>> / <<< S e g m e n t >>> <<< t r e e >>> với :
<<< B I T >>> ₁ : số lượng chỉ số xếp ( để biết có bao nhiêu j ) .
<<< B I T >>> ₂ : tổng vị trí xếp ( để tính nhanh tổng độ dài ) .

Khi đang ở i :

Cần thống kê trong đoạn
[
<<< 𝑖 >>>
+
2
,

<<< 𝑅 >>>
[
<<< 𝑖 >>>
]
−
1
]
[ i + 2 , R [ i ] − 1 ] .

Lấy <<< c n t >>> = số vị trí j trong đoạn , <<< s u m I d x >>> = tổng các vị trí đó .

Tổng điểm do i đóng góp là

∑
<<< 𝑗 >>>
(
<<< 𝑗 >>>
−
<<< 𝑖 >>>
+
1
)
=
<<< s u m I d x >>>
−
<<< c n t >>>
⋅
<<< 𝑖 >>>
+
<<< c n t >>>
.
j
∑
​
( j − i + 1 ) = <<< s u m I d x >>> − <<< c n t >>> ⋅ i + <<< c n t >>> .
Sau khi cộng , chèn i vào hai <<< B I T >>> .

Độ phức tạp

Tính L , R :
<<< 𝑂 >>>
(
<<< 𝑁 >>>
)
O ( N ) .

Sắp theo giá trị và quét với <<< B I T >>> :
<<< 𝑂 >>>
(
<<< 𝑁 >>>
log
⁡
<<< 𝑁 >>>
)
O ( <<< N l o g N >>> ) .

Bộ nhớ
<<< 𝑂 >>>
(
<<< 𝑁 >>>
)
O ( N ) .

Kiểm tra biên
– Mảng ngắn hơn 3 phần tử luôn cho kết quả 0 .
– Khi
<<< 𝑅 >>>
[
<<< 𝑖 >>>
]
−
<<< 𝑖 >>>
<
2
R [ i ] − i < 2 thì bỏ qua vì không đủ độ dài .
– Chú ý dùng chỉ số 1 - <<< i n d e x >>> hay 0 - <<< i n d e x >>> nhất quán trong L , R và <<< B I T >>> .

Tóm tắt thao tác

Với mỗi phần tử , tìm đoạn “ an toàn ” mà nó làm nắp ( dùng <<< s t a c k >>> ) .

Duyệt phần tử theo giá trị giảm dần , <<< B I T >>> lưu các vị trí đã cao hơn hoặc bằng .

Mỗi lần lấy thống kê trong đoạn
[
<<< 𝑖 >>>
+
2
,
<<< 𝑅 >>>
[
<<< 𝑖 >>>
]
−
1
]
[ i + 2 , R [ i ] − 1 ] để cộng điểm .

In tổng điểm sau khi xử lý hết mảng .

Như vậy ta tính được
∑
<<< 𝑆 >>>
<<< 𝑖 >>>
,
<<< 𝑗 >>>
∑ S
i , j
​
cho mảng dài tới một trăm nghìn phần tử trong thời gian hợp lý .