1 . Phân tích bài toán
Mỗi thanh gỗ dài L nếu quyết định cắt sẽ cho ra L thanh dài 1 kèm chi phí a · ( L - 1 ) ² + b .

Nếu không cắt thì :

Với thanh dài 1 : đã có sẵn 1 thanh dài 1 , chi phí 0 .

Với thanh dài ≥ 2 : không đóng góp gì cho khách ( vì khách chỉ nhận thanh dài 1 ) .

Ta phải chọn một tập con các thanh để cắt sao cho tổng số thanh dài 1 thu được ít nhất K và tổng chi phí nhỏ nhất .

Nhận xét : chi phí và lượng “ thu hoạch ” của từng thanh hoàn toàn độc lập ⇒ bài toán trở thành quy hoạch động kiểu “ ba lô ” ( <<< k n a p s a c k >>> ) với :

“ Trọng lượng ” của món hàng = số thanh 1 thu được ( chính là độ dài L ) .

“ Giá ” của món hàng = chi phí cắt thanh đó .

2 . Chuẩn bị dữ liệu
Đếm sẵn số thanh dài 1 trong dãy S . Gọi kết quả là <<< c n t 1 >>> .

Giảm nhu cầu : <<< n e e d >>> = <<< m a x >>> ( 0 , K - <<< c n t 1 >>> ) .

Nếu <<< n e e d >>> = 0 thì đã đủ hàng , in ra 0 và sang test kế tiếp .

Với mỗi thanh có độ dài ≥ 2 , tính trước chi phí cắt <<< c o s t >>> [ i ] = a · ( L - 1 ) ² + b .

3 . Quy hoạch động 1 chiều
Tạo mảng <<< d p >>> kích thước <<< n e e d >>> + <<< m a x L >>> ( tối đa khoảng 10 000 ) ,

<<< d p >>> [ x ] = chi phí nhỏ nhất thu được đúng x thanh dài 1 sau khi xét một số thanh .

Khởi tạo : <<< d p >>> [ 0 ] = 0 , các vị trí khác gán giá trị “ vô cùng lớn ” .

Lần lượt duyệt từng thanh dài ≥ 2 :

Duyệt ngược x từ hiện tại xuống 0 .

Cập nhật : <<< d p >>> [ x + L ] = min ( <<< d p >>> [ x + L ] , <<< d p >>> [ x ] + <<< c o s t >>> ) ( nếu <<< d p >>> [ x ] khả thi ) .

Sau khi xét hết thanh , câu trả lời là giá trị nhỏ nhất của <<< d p >>> [ x ] với x ≥ <<< n e e d >>> .

4 . Chi tiết cần lưu ý
Độ phức tạp :

Số phần tử của <<< d p >>> ≤ tổng độ dài các thanh ( ≤ 10 000 ) .

Vòng lặp : N × 10 000 tối đa ≈ 1 triệu – hoàn toàn ổn cho tới 20 test .

Kiểu số : chi phí có thể rất lớn ( a tới 10⁶ ; ( L - 1 ) ² tới 9 801 ) ⇒ dùng biến 64 <<< b i t >>> .

Thanh dài 1 không bao giờ cắt ; cứ cộng thẳng vào kết quả ban đầu ( đã xử lý ở bước 2 ) .

5 . Tóm tắt luồng giải
Đọc dữ liệu , tách K , dãy S , hệ số a , b .

Đếm sẵn các thanh dài 1 → giảm K .

Nếu đã đủ , in 0 . Ngược lại :

Khởi tạo <<< d p >>> .

Với từng thanh dài ≥ 2 : cập nhật <<< d p >>> như mô tả .

Tìm <<< d p >>> [ x ] nhỏ nhất với x ≥ <<< n e e d >>> → in ra .

Sau khi hiểu quy trình trên , bạn có thể hiện thực bằng ngôn ngữ mình muốn mà không cần dùng lambda hay cú pháp phức tạp .